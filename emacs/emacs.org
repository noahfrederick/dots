#+TITLE: Nox's Emacs Configuration
#+AUTHOR: Noah Frederick

* Usage

** Obtaining the Source

You can find the latest version of the configuration in [[https://github.com/noahfrederick/dots][the GitHub
repository]]. The meat of it (and the source of this document) is the
=emacs.org= file.

** Installation

- Install GNU Emacs 24 or later
- Place =init.el= and =emacs.org= in =~/.emacs.d/=
- Launch Emacs

** Commentary

Any variables, functions, or macros defined in this configuration
are "namespaced" with a prefix of ~my-~. This is only a convention
for easily distinguishing between built-in functions and those
defined in this configuration or another package, and has no other
special significance.

** Configuring Packages

We use [[https://github.com/jwiegley/use-package][use-package]] to autoload packages. It provides a DSL for
setting up autoloads and keybindings, and for deferring the loading
of packages that might otherwise slow down Emacs's startup.

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (use-package use-package
    :config
    (setq use-package-always-pin "melpa-stable"))
#+END_SRC

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package paradox
    :ensure t
    :commands paradox-list-packages)
#+END_SRC

* Emacs Initialization

** Paths

Keep any Elisp files not installed from a package repository in the
=vendor/= directory:

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar my-vendor-directory (concat user-emacs-directory "vendor/"))
  (add-to-list 'load-path my-vendor-directory)
#+END_SRC

Keep theme files in the =themes/= directory:

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no
  (setq custom-theme-directory (concat user-emacs-directory "themes/"))
#+END_SRC

** Benchmarking

It's useful to measure how long it takes Emacs to start up, so
let's show the total time in a message:

#+NAME: init-after
#+BEGIN_SRC emacs-lisp :tangle no :tangle no
  (defun my-show-startup-time ()
    "Show Emacs's startup time in the minibuffer"
    (message "Startup time: %s seconds."
             (emacs-uptime "%s")))

  (add-hook 'emacs-startup-hook 'my-show-startup-time 'append)
#+END_SRC

[[https://github.com/dholm/benchmark-init-el][Benchmark-init.el]] can give us a breakdown of time spent on ~require~
and ~load~ calls:

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no :tangle no
  (use-package benchmark-init-loaddefs
    :ensure benchmark-init
    :init
    (progn
      (benchmark-init/activate)
      (add-hook 'after-init-hook 'benchmark-init/deactivate)))
#+END_SRC

** Platform-specific

There are a few settings that are only relevant to OS X (Darwin):

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no
  (cond ((eq system-type 'darwin)
         (setq delete-by-moving-to-trash t
               trash-directory "~/.Trash/")
         ;; BSD ls does not support --dired. Use GNU core-utils: brew install coreutils
         (when (executable-find "gls")
           (setq insert-directory-program "gls"))
         ;; Derive PATH by running a shell so that GUI Emacs sessions have access to it
         (use-package exec-path-from-shell
           :ensure t
           :config
           (exec-path-from-shell-initialize))
         ;; Point Org to LibreOffice executable
         (when (file-exists-p "/Applications/LibreOffice.app/Contents/MacOS/soffice")
           (setq org-export-odt-convert-processes '(("LibreOffice" "/Applications/LibreOffice.app/Contents/MacOS/soffice --headless --convert-to %f%x --outdir %d %i"))))))
#+END_SRC

** Start Server

The Emacs server allows for using =emacsclient= to quickly pop open a
new frame in a terminal:

#+NAME: init-after
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package server
    :if window-system
    :config
    (unless (server-running-p)
      (server-start)))
#+END_SRC

Here are the most common ways in which =emacsclient= is used:

| Command                         | Description                     |
|---------------------------------+---------------------------------|
| =emacsclient=                     | Edit in existing frame          |
| =emacsclient -n (--no-wait)=      | Do not wait--return immediately |
| =emacsclient -c (--create-frame)= | Edit in a new frame             |
| =emacsclient -t (--tty)=          | Edit in a new terminal frame    |
| =emacsclient -e (--eval)=         | Evaluate the following Elisp    |

For more, see =man emacsclient=.

** Temporary Files

Autosave and backup files (currently disabled) go in =/tmp/=.

#+NAME: init-after
#+BEGIN_SRC emacs-lisp :tangle no
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
  (setq-default make-backup-files nil)
#+END_SRC

** Private

Since this configuration is kept in version control in public view,
we keep sensitive information such as passwords in a separate
file. Anything with the special prefix ~my-private-~ originates from
this file.

#+NAME: init-before
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar my-private-file (expand-file-name "private.el" user-emacs-directory))
  (load my-private-file 'noerror)
#+END_SRC

** Custom

Set alternative location for =custom-set-variables= and =custom-set-faces=:

#+NAME: init-after
#+BEGIN_SRC emacs-lisp :tangle no
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file 'noerror)
#+END_SRC

* Appearance

** Icon

The icon that comes with Emacs for OS X does not meet the standards
of design set by Apple's GUI. We use this icon from the [[https://github.com/numixproject/numix-icon-theme-circle][Numix
Circle icon set]] instead:

[[file:emacs.svg]]

This SVG can be converted into an ICNS file [[http://iconverticons.com/online/][here]].

** Mode-line

The mode-line displays information about the visible buffer at the
bottom of the window. This defines a custom mode line format:

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package powerline
	:ensure t
    :config
    (progn
      (setq-default powerline-default-separator
                    (if (display-graphic-p) 'wave 'utf-8))
      (powerline-default-theme)))
#+END_SRC

** UI

Hide parts of the GUI that we don't need, namely the graphical tool
bar and any scroll bars.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

Load the theme, which determines colors and font variants. Enox is
a medium-contrast theme with a dark background.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (load-theme 'enox t)
#+END_SRC

When loading a different theme, first unload the previous theme
so that it doesn't leave stray customizations behind.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice load-theme (before theme-dont-propagate activate)
   (mapc #'disable-theme custom-enabled-themes))
#+END_SRC

We also set the font while specifying a couple fallbacks. The last
argument of ~set-frame-font~ ensures that new frames inherit the font
as well.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (cond
   ((find-font (font-spec :name "Fira Mono"))
    (set-frame-font "Fira Mono-14" t t)
    (setq-default line-spacing 4))
   ((find-font (font-spec :name "Source Code Pro"))
    (set-frame-font "Source Code Pro-14" t t))
   ((find-font (font-spec :name "Panic Sans"))
    (set-frame-font "Panic Sans-14" t t))
   ((find-font (font-spec :name "courier"))
    (set-frame-font "courier-14" t t)))
#+END_SRC

Highlight the current line.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (global-hl-line-mode)
#+END_SRC

GUI Emacs windows default to a tiny size. Usually, I want the
window to fill the screen:

#+BEGIN_QUOTE
  The developer build of Emacs Trunk has a function called
  ~toggle-frame-maximized~, which is included within
  =.../lisp/frame.el=. That function can be added to the
  ~after-init-hook~ or ~emacs-startup-hook~, or simply included in the
  =.emacs= file that gets loaded on startup. On OSX, it increases
  both width and height in one-fell-swoop.
#+END_QUOTE

Source: http://stackoverflow.com/a/18711628

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (if (fboundp 'toggle-frame-maximized)
      (add-hook 'emacs-startup-hook 'toggle-frame-maximized))
#+END_SRC

Suppress the theme's background color and Emacs's menu bar in
terminal frames:

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-after-make-frame (frame)
    "Function run in after-make-frame-functions hook, which handles
  cosmetic issues in terminal frames."
    (unless (display-graphic-p frame)
      (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
      (set-face-background 'default "dummy-color" frame)))

  (add-hook 'after-make-frame-functions 'my-after-make-frame)
#+END_SRC

Emacs typically beeps to indicate illegal commands. I don't find
this particularly useful, so we disable it.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ring-bell-function 'ignore)
#+END_SRC

Emacs shows an unwelcome "startup screen" upon launch. Here we
disable it.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (setq inhibit-startup-screen t)
#+END_SRC

Set the initial text contents of the =*scratch*= buffer. A value of ~nil~
suppresses the message altogether.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (setq initial-scratch-message nil)
#+END_SRC

Use ANSI color in shell:

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

Never require full word answers to yes/no prompts:

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Use a line number format that allows for five digits with some padding
to the right of the numbers.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (setq linum-format "%5d ")
#+END_SRC

** Popwin

[[https://github.com/m2ym/popwin-el][Popwin]] forces certain buffers into a temporary window with fixed
height that spans the entire width of the frame.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package popwin
    :ensure t
    :commands popwin-mode
    :defer 2
    :config
    (progn
      (popwin-mode 1)
      (push '("*Org Agenda*" :width 82 :position right :dedicated t :stick t) popwin:special-display-config)
      (push '("*helm*" :height 20) popwin:special-display-config)
      (push '("^\*helm .+\*$" :regexp t :height 20) popwin:special-display-config)
      (push '("*Compile-Log*" :height 20 :noselect t) popwin:special-display-config)))
#+END_SRC

** Delimiters

The rainbow-delimiters package differentiates levels of nested
parentheses by color. This is mostly useful for visually parsing
Lisp's parenthesis-heavy syntax.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :init
    (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

Highlight matching parenthesis, brace, etc.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (show-paren-mode t)
#+END_SRC

** Color Names and Codes

Rainbow mode displays textual color representations with a
corresponding colored background.

#+NAME: appearance
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rainbow-mode
    :ensure t
    :commands rainbow-turn-on
    :init
    (add-hook 'prog-mode-hook 'rainbow-turn-on)
    :config
    (setq rainbow-x-colors nil))
#+END_SRC

* Key Bindings

** General

Instantly display current key sequence in mini buffer:

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (setq echo-keystrokes 0.02)
#+END_SRC

When opening a new line with =RET=, indent it appropriately:

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

** Evil

Evil mode is a minor mode providing Vim emulation for Emacs. It
reproduces Vim's modal editing and even certain Ex commands.

Evil Leader mode provides something like Vim's =<Leader>=, which is
set to =SPC= below. Here are the conventions used throughout the
configuration around "namespacing" sets of commands bound to the
leader key:

| Key | Description                 |
|-----+-----------------------------|
| =g=   | Git functions (via Magit)   |
| =o=   | Option (minor-mode) toggles |
| =r=   | Global Org mode functions   |

(Evil Leader mode has to be initialized before Evil mode to work
around [[https://github.com/cofi/evil-leader/issues/10][a limitation]].)

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil
    :ensure t
    :init
    (progn
      (setq evil-want-C-w-in-emacs-state t)
      (use-package evil-leader
        :ensure t
        :config
        (progn
          (evil-leader/set-leader "<SPC>")
          (global-evil-leader-mode 1)

          (defun my-declare-prefix (prefix name)
            "Declare a prefix PREFIX. PREFIX is a string describing
  a key sequence. NAME is a symbol name used as the prefix command."
            (let ((command (intern (concat "group:" name))))
              ;; Define the prefix command only if it does not already exist
              (unless (lookup-key evil-leader--default-map prefix)
                (define-prefix-command command)
                (evil-leader/set-key prefix command))))

          ;; Define prefix commands for the sake of guide-key
          (setq my-key-binding-prefixes '(("g" . "git")
                                           ("m" . "mode")
                                           ("o" . "toggle")
                                           ("r" . "org")))

          (mapc (lambda (x) (my-declare-prefix (car x) (cdr x)))
                my-key-binding-prefixes)

          (evil-leader/set-key
            "SPC" 'smex
            "m SPC" 'smex-major-mode-commands
            "=" 'my-indent-buffer
            "b" 'ido-switch-buffer
            "B" 'ibuffer
            "d" 'projectile-find-dir
            "D" 'dired
            "e" 'ido-find-file
            "f" 'projectile-find-file
            "k" 'kill-this-buffer
            "K" 'dash-at-point
            "p" 'projectile-switch-project
            "P" 'paradox-list-packages
            "s" 'ansi-term
            "T" 'my-write-timestamped-current-file-copy
            "u" 'undo-tree-visualize
            "w" 'whitespace-cleanup
            "y" 'my-yank-buffer
            "z" 'my-narrow-or-widen
            ;; Option toggle
            "o l" 'whitespace-mode
            "o n" 'linum-mode
            "o q" 'auto-fill-mode
            "o w" 'visual-line-mode)))

      (use-package evil-numbers
        :ensure t
        :config
        (progn
          (define-key evil-normal-state-map "+" 'evil-numbers/inc-at-pt)
          (define-key evil-normal-state-map "_" 'evil-numbers/dec-at-pt))))
    :config
    (progn
      (setq evil-default-cursor '("DodgerBlue1" box)
            evil-normal-state-cursor '("orange" box)
            evil-emacs-state-cursor '("pink" box)
            evil-motion-state-cursor '("SeaGreen1" box)
            evil-insert-state-cursor '("orange" bar)
            evil-visual-state-cursor '("orange" hbar)
            evil-replace-state-cursor '("orange" hbar))

      (evil-mode 1)

      ;; Override the starting state in a few major modes
      (evil-set-initial-state 'magit-mode 'emacs)
      (evil-set-initial-state 'org-agenda-mode 'emacs)
      (evil-set-initial-state 'package-menu-mode 'motion)
      (evil-set-initial-state 'paradox-menu-mode 'motion)
      (evil-set-initial-state 'mu4e-main-mode 'motion)
      (evil-set-initial-state 'mu4e-view-mode 'motion)
      (evil-set-initial-state 'mu4e-headers-mode 'motion)
      (evil-set-initial-state 'elfeed-search-mode 'motion)
      (evil-set-initial-state 'elfeed-show-mode 'motion)

      ;; Reclaim useful keys from evil-motion-state-map
      (define-key evil-motion-state-map (kbd "RET") nil)
      (define-key evil-motion-state-map (kbd "TAB") nil)

      (define-key minibuffer-local-map (kbd "C-w") 'backward-kill-word)

      (define-key evil-motion-state-map "j" 'evil-next-visual-line)
      (define-key evil-motion-state-map "k" 'evil-previous-visual-line)
      (define-key evil-normal-state-map "Y" (kbd "y$"))

      ;; Experimental alternative to C-d, C-u
      (define-key evil-normal-state-map (kbd "C-k") 'evil-scroll-up)
      (define-key evil-normal-state-map (kbd "C-j") 'evil-scroll-down)
      (define-key evil-motion-state-map (kbd "C-k") 'evil-scroll-up)
      (define-key evil-motion-state-map (kbd "C-j") 'evil-scroll-down)

      ;; Commentary.vim
      (use-package evil-operator-comment
        :config
        (global-evil-operator-comment-mode 1))

      ;; Vinegar.vim
      (autoload 'dired-jump "dired-x"
        "Jump to Dired buffer corresponding to current buffer." t)
      (define-key evil-normal-state-map "-" 'dired-jump)
      (evil-define-key 'normal dired-mode-map "-" 'dired-up-directory)

      ;; Unimpaired.vim
      (define-key evil-normal-state-map (kbd "[ SPC")
        (lambda () (interactive) (evil-insert-newline-above) (forward-line)))
      (define-key evil-normal-state-map (kbd "] SPC")
        (lambda () (interactive) (evil-insert-newline-below) (forward-line -1)))
      (define-key evil-normal-state-map (kbd "[ e") (kbd "ddkP"))
      (define-key evil-normal-state-map (kbd "] e") (kbd "ddp"))
      (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer)
      (define-key evil-normal-state-map (kbd "] b") 'next-buffer)))
#+END_SRC

Additionally, let's make =ESC= work more or less like it does in
Vim. Use =ESC= to cancel out of the minibuffer:

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-minibuffer-keyboard-quit ()
    "Abort recursive edit.

  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (define-key minibuffer-local-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'my-minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'my-minibuffer-keyboard-quit)
#+END_SRC

* Editing

** Text Encodings

Use UTF-8 encoding wherever possible:

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (set-default-coding-systems 'utf-8-unix)
  (set-terminal-coding-system 'utf-8-unix)
  (set-keyboard-coding-system 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC

Even so, ~ansi-term~ doesn't obey:

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice ansi-term (after advise-ansi-term-coding-system)
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (ad-activate 'ansi-term)
#+END_SRC

** Utilities

These packages provide various conveniences for editing.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil-surround
    :ensure t
    :commands global-evil-surround-mode
    :config (global-evil-surround-mode 1)
    :defer 2)

  (use-package smartparens-config
    :ensure smartparens
    :diminish smartparens-mode
    :commands smartparens-global-mode
    :defer 2
    :config
    (progn
      (smartparens-global-mode t)
      ;; Smartparens manipulations
      ;; See all of them here:
      ;; https://github.com/Fuco1/smartparens/wiki/Working-with-expressions
      (evil-define-key 'normal emacs-lisp-mode-map
        (kbd "C-S-k") 'sp-split-sexp
        (kbd "C-S-j") 'sp-join-sexp
        (kbd "C-S-l") 'sp-forward-slurp-sexp
        (kbd "C-S-h") 'sp-backward-slurp-sexp
        (kbd "C-M-l") 'sp-forward-barf-sexp
        (kbd "C-M-h") 'sp-backward-barf-sexp)

      ;; Fix handling of {} and [] when hitting RET inside
      (defun my-sp/pair-on-newline (id action context)
        "Put trailing pair on newline and return to point."
        (save-excursion
          (newline)
          (indent-according-to-mode)))

      (defun my-sp/pair-on-newline-and-indent (id action context)
        "Open a new brace or bracket expression, with relevant newlines and indent."
        (my-sp/pair-on-newline id action context)
        (indent-according-to-mode))

      (sp-pair "{" nil :post-handlers
               '(:add ((lambda (id action context)
                         (my-sp/pair-on-newline-and-indent id action context)) "RET")))
      (sp-pair "[" nil :post-handlers
               '(:add ((lambda (id action context)
                         (my-sp/pair-on-newline-and-indent id action context)) "RET")))))
#+END_SRC

When proper source control isn't an option, it's useful to be able
to create a copy of a file as you are working on it.
~my-write-timestamped-current-file-copy~ writes the contents of the
active buffer to a copy with a timestamp appended to the filename.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-write-file-copy (filename)
    (interactive "F")
    (save-restriction (widen)
                      (write-region (point-min) (point-max) filename)))

  (defun my-write-timestamped-file-copy (filename)
    (interactive "F")
    (let ((timestamp (format-time-string "%Y%m%d-%H%M%S"))
          (filename-head (file-name-sans-extension filename))
          (filename-ext (file-name-extension filename t)))
      (my-write-file-copy (expand-file-name (concat filename-head "_" timestamp filename-ext)))))

  (defun my-write-timestamped-current-file-copy ()
    (interactive)
    (my-write-timestamped-file-copy (buffer-file-name)))
#+END_SRC

Copying the entire buffer contents to the clipboard is a fairly
common need when working with other graphical programs.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-yank-buffer ()
    "Copy entire buffer to clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))
#+END_SRC

The following function removes the file associated with the current
buffer from disk. We also define an Evil ex command ~:Remove~ that
works like that from [[https://github.com/tpope/vim-eunuch][eunuch.vim]].

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-delete-current-file ()
    "Delete the file associated with the current buffer and close the
  buffer. When no file is associated with the buffer, the buffer is
  closed only."
    (interactive)
    (let ((current (buffer-file-name)))
      (kill-buffer (current-buffer))
      (when current
        (delete-file current))))


  (with-eval-after-load 'evil
    (evil-ex-define-cmd "R[emove]" 'my-delete-current-file))
#+END_SRC

** Scrolling

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (setq scroll-conservatively 999        ; Never recenter the window on the cursor
        mouse-wheel-scroll-amount '(1))  ; Slower mouse wheel/trackpad scrolling
#+END_SRC

** Windows

Resizing windows in Emacs isn't very intuitive. Rather than
expanding or contracting the current window, it makes more sense to
conceptualize moving the border between windows, which [[https://github.com/ramnes/move-border][move-border]]
accomplishes.

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package move-border
    :commands (move-border-left
               move-border-right
               move-border-up
               move-border-down)
    :init
    (progn
      (define-key evil-normal-state-map (kbd "<left>") 'move-border-left)
      (define-key evil-normal-state-map (kbd "<right>") 'move-border-right)
      (define-key evil-normal-state-map (kbd "<up>") 'move-border-up)
      (define-key evil-normal-state-map (kbd "<down>") 'move-border-down)))
#+END_SRC

Here we create a mapping to narrow the buffer in an intelligent way
based on the concept in [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][this post by Artur Malabarba]].

#+NAME: evil
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-narrow-or-widen (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p))
           (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((and (boundp 'org-src-mode) org-src-mode (not p))
           (org-edit-src-exit))
          ((derived-mode-p 'org-mode)
           (cond ((org-in-src-block-p)
                  (org-edit-src-code))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))
#+END_SRC

** Whitespace and Formatting

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (setq-default indent-tabs-mode nil)

  (defun my-indent-use-tabs ()
    (setq indent-tabs-mode t))
  (add-hook 'markdown-mode-hook 'my-indent-use-tabs)
  (add-hook 'web-mode-hook 'my-indent-use-tabs)

  (use-package dtrt-indent
    :ensure t
    :config (dtrt-indent-mode 1))
#+END_SRC

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (setq require-final-newline t) ; auto-insert final newlines in all files

  (use-package whitespace
    :ensure t
    :commands (whitespace-cleanup
               whitespace-mode)
    :config
    (progn
      (setq whitespace-line-column nil) ; Use value of fill-column
      (setq whitespace-style '(face
                               tabs
                               spaces
                               trailing
                               lines-tail
                               space-before-tab
                               newline
                               indentation
                               empty
                               space-after-tab
                               space-mark
                               tab-mark
                               newline-mark))))

  (defun my-indent-buffer ()
          (interactive)
          (save-excursion
                  (indent-region (point-min) (point-max) nil)))

  (defun my-show-trailing-whitespace ()
          (interactive)
          (setq show-trailing-whitespace t))

  (add-hook 'prog-mode-hook
            'my-show-trailing-whitespace)
#+END_SRC

Auto-filling refers to hard-wrapping text. The default fill-column
is 80. We adjust this value for specific modes as needed.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (setq comment-auto-fill-only-comments t)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'prog-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Spelling

Use aspell for spell checking: =brew install aspell --lang=en=

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell
    :ensure t
    :defer 2
    :init
    (defun my-flyspell-setup ()
      "Setup of flyspell-mode."
      (add-hook 'text-mode-hook 'flyspell-mode)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode))
    :config
    (progn
      (setq ispell-program-name "aspell")
      (my-flyspell-setup)))
#+END_SRC

** Syntax Checking

Use [[https://github.com/flycheck/flycheck][Flycheck]] to validate syntax on the fly.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck
    :ensure t
    :commands global-flycheck-mode
    :defer 2
    :config
    (progn
      (global-flycheck-mode 1)
      (setq-default flycheck-disabled-checkers '(html-tidy emacs-lisp-checkdoc))))
#+END_SRC

** Version Control and History

Undo tree provides a Vim-like branching undo history that can be
visualized and traversed in another window.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (setq undo-tree-visualizer-diff t
          undo-tree-visualizer-timestamps t))
#+END_SRC

Magit provides featureful Git integration.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package magit
    :ensure t
    :commands (magit-status magit-diff magit-log magit-blame-mode)
    :init
    (evil-leader/set-key
      "g s" 'magit-status
      "g b" 'magit-blame-mode
      "g l" 'magit-log
      "g d" 'magit-diff
      "g r" 'vc-revert)
    :config
    (progn
      (evil-make-overriding-map magit-mode-map 'emacs)
      (define-key magit-mode-map "\C-w" 'evil-window-map)
      (evil-define-key 'emacs magit-mode-map "j" 'magit-goto-next-section)
      (evil-define-key 'emacs magit-mode-map "k" 'magit-goto-previous-section)
      (evil-define-key 'emacs magit-mode-map "K" 'magit-discard-item))) ; k
#+END_SRC

[[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]] shows the version control status of lines in the
fringe. There are at least four different implementations out
there. Some use the window margin (and conflict with linum-mode), some
use the fringe (and don't work in a terminal).

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package git-gutter-fringe
    :ensure t
    :diminish git-gutter-mode
    :config
    (progn
      (global-git-gutter-mode t)

      (evil-leader/set-key "g u u" 'global-git-gutter-mode)))
#+END_SRC

** Languages

*** Emacs-Lisp

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package emacs-lisp-mode
    :init
    (progn
      (evil-leader/set-key-for-mode 'emacs-lisp-mode
        "m C" 'byte-compile-file
        "m e" 'eval-defun
        "m E" 'eval-buffer
        "m x" 'eval-last-sexp
        "m X" 'eval-print-last-sexp)

      (use-package eldoc
        :commands turn-on-eldoc-mode
        :init (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)))
    :mode ("Cask" . emacs-lisp-mode))

  (defun my-byte-recompile ()
    "`byte-compile' every .el file under `user-emacs-directory' recursively"
    (interactive)
    (byte-recompile-directory user-emacs-directory 0)
    (when (fboundp 'sauron-add-event)
      (sauron-add-event 'editor 2 "Byte compiled Emacs directory")))

  (defun my-byte-compile-current-buffer ()
    "`byte-compile' current buffer in emacs-lisp-mode if compiled file exists."
    (interactive)
    (when (and (eq major-mode 'emacs-lisp-mode)
               (file-exists-p (byte-compile-dest-file buffer-file-name)))
      (byte-compile-file buffer-file-name)
      (when (fboundp 'sauron-add-event)
        (sauron-add-event 'editor 2 "Byte compiled buffer"))))

  (add-hook 'after-save-hook 'my-byte-compile-current-buffer)
#+END_SRC

*** Ledger

Ledger mode is for working with the file format associated with the
command-line accounting program.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ledger-mode
    :ensure t
    :mode (("\\.ledger\\'" . ledger-mode))
    :config
    (progn
      (setq ledger-post-use-completion-engine :ido)
      (evil-leader/set-key-for-mode 'ledger-mode
        "m a" 'ledger-add-transaction
        "m b" 'ledger-post-edit-amount
        "m c" 'ledger-toggle-current
        "m D" 'ledger-delete-current-transaction
        "m p" 'ledger-display-balance-at-point
        "m q" 'ledger-post-align-xact
        "m Q" 'ledger-mode-clean-buffer
        "m r" 'ledger-report
        "m R" 'ledger-reconcile
        "m /" 'my-ledger-post-split-evenly
        "m ?" 'my-ledger-post-split
        "m s" 'ledger-display-ledger-stats
        "m t" 'ledger-insert-effective-date
        "m y" 'ledger-set-year
        "m m" 'ledger-set-month)))
#+END_SRC

These are helper functions I use to manage my ledger file.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'ledger-mode
    (defun my-ledger-post-split (account amount)
      "Split a ledger posting at point between original account and
  ACCOUNT, with AMOUNT allotted to the second account."
      (interactive (list (my-ledger-org-read-account)
                         (string-to-number (read-string "Amount ($): "))))
      (my-ledger-post-make-split account amount))

    (defun my-ledger-post-split-evenly (account)
      "Split a ledger posting at point evenly between original account and ACCOUNT."
      (interactive (list (my-ledger-org-read-account)))
      (my-ledger-post-make-split account))

    (defun my-ledger-post-make-split (account &optional amount)
      "Split a ledger posting at point between original account and ACCOUNT."
      (goto-char (line-beginning-position))
      (when (re-search-forward ledger-post-line-regexp (line-end-position) t)
        ;; Go to the end of the account to search forward for an amount
        (goto-char (match-end ledger-regex-post-line-group-account))
        (let ((end-of-amount (re-search-forward "[-.,0-9]+" (line-end-position) t)))
          (if end-of-amount
              (let* ((val-original (string-to-number (match-string 0)))
                     (amount (if amount amount
                               ;; Else split evenly, allowing for a 1-cent remainder
                               (/ (floor (* 50.0 val-original)) 100.0)))
                     (val-1 (format "%.2f" (- val-original amount)))
                     (val-2 (format "%.2f" amount)))
                (goto-char (match-beginning 0))
                (delete-region (match-beginning 0) (match-end 0))
                (insert val-1)
                (ledger-post-align-postings)
                (insert "\n    " account "  $" val-2)
                (ledger-post-align-postings))
            (message "This posting has no amount"))))))
#+END_SRC

*** Puppet

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package puppet-mode
    :ensure t
    :mode (("\\.pp\\'" . puppet-mode)))
#+END_SRC

*** Rest Client

The [[https://github.com/pashky/restclient.el][restclient]] package provides a REPL-like interface for HTTP
requests. Also there's an [[http://emacsrocks.com/e15.html][Emacs Rocks! episode showing it off]].

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package restclient
    :ensure t
    :mode ("\\.http\\'" . restclient-mode)
    :config
    (progn
      (evil-leader/set-key-for-mode 'restclient-mode
        "m m" 'restclient-http-send-current-stay-in-window
        "m s" 'restclient-http-send-current-stay-in-window
        "m S" 'restclient-http-send-current)))
#+END_SRC

*** Ruby

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package enh-ruby-mode
    :ensure t
    :mode (("\\.rake\\'" . enh-ruby-mode)
           ("\\.gemspec\\'" . enh-ruby-mode)
           ("\\.ru\\'" . enh-ruby-mode)
           ("Rakefile\\'" . enh-ruby-mode)
           ("Gemfile\\'" . enh-ruby-mode)
           ("Capfile\\'" . enh-ruby-mode)
           ("Puppetfile\\'" . enh-ruby-mode)
           ("Guardfile\\'" . enh-ruby-mode))
    :init
    (progn
      (add-hook 'enh-ruby-mode-hook 'robe-mode)
      (add-hook 'robe-mode-hook 'ac-robe-setup)))
#+END_SRC

*** Web

Web mode provides, among other features, syntax highlighting for
Javascript and CSS embedded in HTML as well as highlighting for
various templating languages.

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package web-mode
    :ensure t
    :mode (("\\.html?\\'" . web-mode)
           ("\\.php\\'" . web-mode)
           ("\\.css\\'" . web-mode)
           ("\\.mustache\\'" . web-mode)
           ("\\.erb\\'" . web-mode))
    :init
    (add-hook 'web-mode-hook (lambda ()
                               (set-fill-column 120))))
#+END_SRC

** Snippets

Use [[https://github.com/capitaomorte/yasnippet][YASnippet]] for snippets:

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :defer 2
    :config
    (progn
      ;; Suppress excessive log messages
      (setq yas-verbosity 1
            yas-prompt-functions '(yas-ido-prompt)
            yas-snippet-dir (expand-file-name "snippets" user-emacs-directory))
      (yas-global-mode t)))
#+END_SRC

** Expansion

Use [[http://www.gnu.org/software/emacs/manual/html_node/autotype/Hippie-Expand.html][hippie-expand]] for inline expansion in all modes:

#+NAME: editing
#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

* Navigation and Completion

** Save Place

Place the point where we left it when last visiting the same file.

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package saveplace
    :init
    (setq-default save-place t))
#+END_SRC

** Ido

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido
    :config
    (progn
      (ido-mode t)
      (ido-everywhere t)

      (use-package ido-ubiquitous
        :ensure t
        :config (ido-ubiquitous-mode t)))

      (setq ido-enable-flex-matching t
            ido-use-virtual-buffers t
            ido-create-new-buffer 'always) ; Do not prompt when creating new file
      (add-to-list 'ido-ignore-files "\\.DS_Store")

      (add-hook 'ido-setup-hook 'my-ido-setup)

      (defun my-ido-setup ()
        "Add Evil-mode-like key bindings for ido."
        (define-key ido-completion-map (kbd "C-j") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-k") 'ido-prev-match)
        (define-key ido-buffer-completion-map (kbd "C-d") 'ido-kill-buffer-at-head) ; Originally C-k
        (define-key ido-file-completion-map (kbd "C-d") 'ido-delete-file-at-head)
        (define-key ido-file-completion-map (kbd "C--") 'ido-enter-dired)) ; Originally C-d

      (use-package ido-vertical-mode
        :ensure t
        :config
        (ido-vertical-mode)))
#+END_SRC

** Smex

Smex provides Ido completion for =M-x=.

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smex
    :ensure t
    :bind (("M-x" . smex)
           ("M-X" . smex-major-mode-commands))
    :config
    (progn
      (setq smex-history-length 10)
      (setq smex-flex-matching t)
      (smex-initialize)))
#+END_SRC

** Find in Project

[[https://github.com/bbatsov/projectile][Projectile]] allows easy switching between projects as well as
finding files and buffers related to the current project, however
it does not implement its own interface, instead leveraging Ido,
Helm, or Grizzl.

Projectile's bindings start with =C-c p=.

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package projectile
    :ensure t
    :config
    (progn
      (setq projectile-show-paths-function 'projectile-hashify-with-relative-paths)
      (add-to-list 'projectile-globally-ignored-files ".DS_Store") ; FIXME: Only works for file in root
      (projectile-global-mode)))
#+END_SRC

** Auto-completion

Use [[http://cx4a.org/software/auto-complete/index.html][Auto Complete Mode]] for inline completion in certain major modes:

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auto-complete-config
    :ensure auto-complete
    :diminish auto-complete-mode
    :commands ac-config-default
    :defer 2
    :init
    (progn
      ;; The default value of ac-sources is
      ;; '(ac-source-abbrev ac-source-dictionary ac-source-words-in-same-mode-buffers)
      ;; and then this is overridden for a handful of major modes.
      ;;
      ;; Add a couple of non-default sources to ac-sources for all buffers
      ;; by redefining this function called from (ac-config-default):
      (defun ac-common-setup ()
        (setq ac-sources (append ac-sources '(ac-source-yasnippet
                                              ac-source-filename))))

      (setq ac-auto-start 1)) ; Number of characters typed before completion starts
    :config
    (progn
      (ac-config-default)
      (use-package pos-tip
        :ensure t)

      (add-to-list 'ac-dictionary-directories (expand-file-name "ac-dict" user-emacs-directory))
      ;; User-defined dictionary goes in "~/.dict" by default.

      (ac-flyspell-workaround)
      (ac-linum-workaround)))
#+END_SRC

** Key Bindings

Completion of sorts for key sequences is provided by [[https://github.com/kbkbkbkb1/guide-key][guide-key]]:

#+NAME: navigation-completion
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package guide-key
    :ensure t
    :diminish guide-key-mode
    :commands guide-key-mode
    :defer 2
    :config
    (progn
      (setq guide-key/recursive-key-sequence-flag t
            guide-key/align-command-by-space-flag t
            guide-key/popup-window-position 'bottom)

      (setq guide-key/highlight-command-regexp
            '("group:" . guide-key/prefix-command-face))

      ;; Sequences of interest globally
      (setq guide-key/guide-key-sequence '("SPC"     ; Evil leader key
                                           "\["
                                           "\]"
                                           "g"
                                           "z"
                                           "C-h"     ; Help commands
                                           "C-x r"   ; Register commands
                                           "C-x 4"   ; Other window commands
                                           "C-x 5"   ; Other frame commands
                                           "C-x c"   ; Helm prefix
                                           "C-c"))   ; Mode commands

      ;; Sequences of interest for specific modes
      (defun guide-key/my-hook-function-for-org-mode ()
        (guide-key/add-local-highlight-command-regexp "org-"))
      (add-hook 'org-mode-hook #'guide-key/my-hook-function-for-org-mode)

      (defun guide-key/my-hook-function-for-markdown-mode ()
        (guide-key/add-local-highlight-command-regexp "markdown-\\|outline-"))
      (add-hook 'markdown-mode-hook #'guide-key/my-hook-function-for-markdown-mode)

      (defun guide-key/my-hook-function-for-mail-modes ()
        (guide-key/add-local-highlight-command-regexp "message-\\|mail-\\|mml-"))
      (add-hook 'mu4e-compose-mode-hook #'guide-key/my-hook-function-for-mail-modes)
      (add-hook 'mu4e-headers-mode-hook #'guide-key/my-hook-function-for-mail-modes)
      (add-hook 'mu4e-view-mode-hook #'guide-key/my-hook-function-for-mail-modes)

      (guide-key-mode 1)))
#+END_SRC

* Org

** Org Files

| contacts.org | Database of contacts; provides completion for email addresses  |
| diary.org    | Date-based notes; where events and daily notes are logged      |
| food.org     | Cooking recipes and notes on restaurants                       |
| inbox.org    | Where new, unfiled tasks and notes are collected               |
| routine.org  | Where recurring tasks are stored                               |
| zombies.org  | Notes and tasks related to survival in catastrophic conditions |

** Basic Settings

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org
    :ensure org-plus-contrib
    :config
    (progn
      (use-package evil-org
        :diminish evil-org-mode)
      (use-package org-mac-link
        :commands org-mac-grab-link)

      ;; Track habits
      (add-to-list 'org-modules 'org-habit)
      (use-package org-habit
        :config
        (setq org-habit-show-habits-only-for-today t
              org-habit-show-done-always-green t))

      (setq org-directory "~/org"
            org-default-notes-file (expand-file-name "inbox.org" org-directory))

      (use-package org-contacts
        :config
        (setq org-contacts-files `(,(expand-file-name "contacts.org" org-directory))
              org-contacts-icon-use-gravatar nil))

      (defun my-ledger-org-read-date ()
        "Read date in an Org mode capture template in the format that
  Ledger expects. Includes a custom prompt string."
        (let ((org-read-date-prefer-future nil))
          (replace-regexp-in-string "-" "/"
                                    (org-read-date nil nil nil "Transaction"))))

      (defun my-ledger-org-read-account ()
        "Read account name using `ido-completing-read'"
        (ido-completing-read "Account: "
                             (split-string
                              (with-output-to-string
                                (shell-command "ledger --permissive accounts" standard-output))
                              "\n" t)))

      (defun my-ledger-org-read-payee ()
        "Read payee name using `ido-completing-read'"
        (ido-completing-read "Payee: "
                             (split-string
                              (with-output-to-string
                                (shell-command "ledger --permissive payees" standard-output))
                              "\n" t)))

      (setq org-capture-templates
            '(("t" "‚òëÔ∏è To-do" entry
               (file+headline "" "Tasks")
               "* TODO %?\nSCHEDULED: %t"
               :clock-keep t :kill-buffer t)
              ("n" "üìî Note" entry
               (file+headline "" "Notes")
               "* Note taken on %U\n%?"
               :clock-keep t :kill-buffer t :jump-to-captured t)
              ("j" "üìÜ Journal entry" entry
               (file+datetree+prompt (expand-file-name "diary.org" org-directory))
               "* %?\n%U\n"
               :clock-keep t :kill-buffer t)
              ("e" "üóìÔ∏è Calendar event" entry
               (file+datetree+prompt (expand-file-name "diary.org" org-directory))
               "* %^{Event name}%^{Location}p\n%T\n%?"
               :clock-keep t :kill-buffer t)
              ("p" "üìì Phrase" entry
               (file+headline (expand-file-name "vocabulary.org" org-directory) "Phrases")
               "* %?"
               :clock-keep t :kill-buffer t :jump-to-captured t)
              ("c" "üë§ Contact" entry
               (file+headline (expand-file-name "contacts.org" org-directory) "People")
               "* %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:END:"
               :clock-keep t :kill-buffer t)
              ("r" "üç≤ Recipe" entry
               (file+headline (expand-file-name "food.org" org-directory) "Recipes")
               "* %^{Recipe Name}%^{source}p%^{serves}p%^{time}p\n\n** Ingredients\n\n** Preparation"
               :clock-keep t :empty-lines 1 :kill-buffer t)
              ("R" "üç¥ Restaurant" entry
               (file+headline (expand-file-name "food.org" org-directory) "Restaurants")
               "* %^{Restaurant Name}\n%u\n"
               :clock-keep t :empty-lines 1 :kill-buffer t)
              ("k" "üî† Keyboards" entry
               (file+headline (expand-file-name "keyboards.org" org-directory) "Keyboard Gallery")
               "* %^{Title}%^{source}p\n#+CAPTION: %^{Caption text}\n%?"
               :clock-keep t :jump-to-captured t)))

      (setq org-goto-interface 'outline-path-completion
            org-log-done 'time
            org-log-into-drawer t
            org-treat-S-cursor-todo-selection-as-state-change nil ; Cycle through TODO states with S-Left/Right skipping logging
            org-deadline-warning-days 1
            org-refile-targets '((org-agenda-files :maxlevel . 2))
            org-refile-target-verify-function 'my-verify-refile-target
            org-refile-allow-creating-parent-nodes 'confirm
            org-refile-use-outline-path t
            org-outline-path-complete-in-steps nil
            org-completion-use-ido t
            org-indirect-buffer-display 'current-window
            org-return-follows-link t
            org-catch-invisible-edits 'show-and-error)

      (setq org-todo-keywords '((sequence
                                 "TODO(t)"
                                 "FOCUS(f)"
                                 "STARTED(s!)"
                                 "WAITING(w@/!)"
                                 "|"
                                 "CANCELED(c@)"
                                 "DONE(d!)"
                                 )))

      (defun my-verify-refile-target ()
        "Exclude TODO keywords with a done state from refile targets"
        (not (member (nth 2 (org-heading-components)) org-done-keywords)))

      (setq org-startup-indented t)

      ;; Code blocks
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (ledger . t)
         (ruby . t)
         (shell . t)))
      (setq org-src-fontify-natively t
            org-src-tab-acts-natively t
            org-confirm-babel-evaluate nil)))
#+END_SRC

Evil confirm/abort in capture buffers.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'org-capture
    (define-key org-capture-mode-map [remap evil-save-and-close]          'org-capture-finalize)
    (define-key org-capture-mode-map [remap evil-save-modified-and-close] 'org-capture-finalize)
    (define-key org-capture-mode-map [remap evil-quit]                    'org-capture-kill))
#+END_SRC

** Lists

[[https://github.com/calvinwyoung/org-autolist][org-autolist]] provides automatic list continuation on =RET=. This does
not presently work with Evil's =o= and =O=.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-autolist
    :ensure t
    :diminish org-autolist-mode
    :commands org-autolist-mode
    :init
    (progn
      (add-hook 'org-mode-hook #'org-autolist-mode)))
#+END_SRC

** Templates

Org mode provides a mechanism for inserting [[http://orgmode.org/manual/Easy-Templates.html][templates]] into Org
documents. To insert a structural element, type a =<=, followed by a
template selector and =<TAB>=.

** Tags

Org headlines can be tagged such that they are easier to find and
filter. Here we set up reusable tags with mnemonic shortcuts.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-tag-alist '((:startgroup)
                        ("@work" . ?W)     ; Contexts
                        ("@home" . ?H)
                        ("@school" . ?S)
                        ("@errand" . ?E)
                        (:endgroup)
                        ("build" . ?b)     ; Task types
                        ("earn" . ?e)
                        ("learn" . ?l)
                        ("focus" . ?f)     ; Task statuses
                        ("someday" . ?s)
                        ("delegate" . ?d)))
#+END_SRC

** Exporting

These settings control how Org files are exported to other formats. In
particular, we specify HTML5 instead of the default XHTML for HTML
export and clean up some of the generated markup. A [[file:~/.emacs.d/emacs.org][custom style sheet]]
for exported files lives in the =~/.emacs.d= directory.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-hide-emphasis-markers t
        org-export-with-section-numbers nil
        org-export-with-tags 'not-in-toc
        org-export-with-toc 1
        org-export-backends '(html
                              latex
                              md
                              icalendar)
        org-html-htmlize-output-type nil
        org-html-doctype "html5"
        org-html-preamble nil
        org-html-postamble t
        org-html-postamble-format '(("en" "<time>%T</time>"))
        org-html-head-include-default-style nil
        org-html-head-include-scripts nil
        org-html-head nil
        org-html-text-markup-alist '((bold . "<strong>%s</strong>")
                                     (code . "<code>%s</code>")
                                     (italic . "<em>%s</em>")
                                     (strike-through . "<del>%s</del>")
                                     (underline . "<dfn>%s</dfn>") ; Somewhat arbitrary
                                     (verbatim . "<kbd>%s</kbd>")))
#+END_SRC

[[http://orgmode.org/manual/Project-alist.html#Project-alist][Projects]] are predefined rules for exporting files or groups of
files. This Org document is part of the "emacs" project. You can
publish a project by issuing =M-x org-publish-current-project RET= or
=M-x org-publish RET= and then typing the project name at the prompt, or
you can publish all projects by issuing =M-x org-publish-all RET=.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-publish-project-alist
        '(("org-assets"
           :base-directory "~/org/"
           :recursive t
           :base-extension "jpg"
           :publishing-directory "~/Notes/"
           :publishing-function org-publish-attachment)
          ("org-pages"
           :base-directory "~/org/"
           :recursive t
           :base-extension "org"
           :publishing-directory "~/Notes/"
           :publishing-function org-html-publish-to-html)
          ("org" :components ("org-assets" "org-pages"))
          ("ledger-assets"
           :base-directory "~/.emacs.d/"
           :recursive nil
           :base-extension "css\\|js"
           :publishing-directory "~/ledger/reports/"
           :publishing-function org-publish-attachment)
          ("ledger-reports"
           :base-directory "~/ledger/reports/"
           :recursive nil
           :base-extension "org"
           :publishing-directory "~/ledger/reports/"
           :publishing-function org-html-publish-to-html
           :headline-levels 9)
          ("ledger" :components ("ledger-assets" "ledger-reports"))))
#+END_SRC

** Key Bindings

*** Hierarchy

| Binding        | Function                                     |
|----------------+----------------------------------------------|
| =M-<left/right>= | Promote/demote current headline or list item |
| =M-<enter>=      | Create new item at current level             |
| =M-S-<enter>=    | Create new TODO at current level             |

*** To-Dos

| Binding     | Function                                       |
|-------------+------------------------------------------------|
| =C-c C-t=     | Cycle state                                    |
| =C-c C-s=     | Schedule it                                    |
| =C-c C-d=     | Set deadline                                   |
| =C-c <comma>= | Set priority                                   |
| =S-<up/down>= | Increase/decrease priority of current headline |
| =C-c C-c=     | Toggle checkbox state                          |
| =C-u C-c C-c= | Toggle checkbox presence                       |

*** Links

| Binding | Function                    |
|---------+-----------------------------|
| =C-c C-l= | Insert link or edit current |

*** Dates and Times

| Binding               | Function                                              |
|-----------------------+-------------------------------------------------------|
| =C-c .=                 | Insert timestamp (use twice to insert range)          |
| =C-c !=                 | Insert inactive timestamp (doesn't appear in agendas) |
| =C-u C-c .= / =C-u C-c != | Like above but including time                         |
| =S-<left/right>=        | Increment/decrement by day                            |
| =S-<up/down>=           | Increment/decrement segment at cursor                 |
| =C-c C-y=               | Evaluate time range and insert after range text       |

*** Tags

| Binding | Function       |
|---------+----------------|
| =C-c C-q= | Tag a headline |

*** Archiving

| Binding         | Function                                                |
|-----------------+---------------------------------------------------------|
| =C-c C-x C-a=     | Archive current item                                    |
| =C-u C-c C-x C-s= | Prompt to archive each non-TODO subtree of current item |

*** Clocking tasks

| Binding                   | Function                                                      |
|---------------------------+---------------------------------------------------------------|
| =C-c C-x C-i= / =C-c C-x C-o= | Clock in/clock out                                            |
| =C-u C-c C-x C-i=           | Select from list of recently clocked tasks                    |
| =C-u C-u C-c C-x C-i=       | Clock into the task at point and mark it as the default task  |
| =C-u C-u C-u C-c C-x C-i=   | Start clock at point at time last clock stopped               |
| =C-c C-x C-x=               | Clock in last clocked task                                    |
| =C-u C-c C-x C-x=           | As above, but select from recently clocked tasks              |
| =C-u C-u C-c C-x C-x=       | As above, but start clock at time last clock stopped          |
| =C-S-<up/down>=             | On ~CLOCK~ log lines, shift both timestamps preserving duration |
| =C-c C-x C-q=               | Cancel current clock                                          |
| =C-c C-x C-j=               | Jump to currently clocked in item                             |

Note: The clock is automatically stopped on tasks when you mark them as DONE.

*** Source Code

| Binding            | Function                              |
|--------------------+---------------------------------------|
| =C-c <single-quote>= | Edit current ~SRC~ block in native mode |

*** Customizations

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Org mode - http://orgmode.org/guide/Activation.html#Activation
  (evil-leader/set-key
    "a"   'org-agenda
    "c"   'org-capture
    "r b" 'org-iswitchb
    "r c" 'my-open-org-calendar
    "r l" 'org-store-link)

  (evil-leader/set-key-for-mode 'org-mode
    "m A" 'org-archive-subtree-default
    "m a" 'org-archive-subtree-default-with-confirmation
    "m d" 'org-deadline
    "m e" 'org-export-dispatch
    "m g" 'org-goto
    "m m" 'org-ctrl-c-ctrl-c
    "m P" 'org-set-property-and-value
    "m p" 'org-set-property
    "m q" 'org-set-tags-command
    "m r" 'org-refile
    "m s" 'org-schedule
    "m t" 'org-todo)

  (with-eval-after-load 'org-agenda
    ;; Use the standard Org agenda bindings as a base
    (evil-make-overriding-map org-agenda-mode-map 'emacs t)
    (evil-define-key 'emacs org-agenda-mode-map "j" 'org-agenda-next-line)
    (evil-define-key 'emacs org-agenda-mode-map "k" 'org-agenda-previous-line)
    (evil-define-key 'emacs org-agenda-mode-map (kbd "C-j") 'org-agenda-goto-date) ; "j"
    (evil-define-key 'emacs org-agenda-mode-map "n" 'org-agenda-capture))          ; "k"
#+END_SRC

** Clocking Time

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-clock
    :config
    (progn
      (setq org-clock-persist t
            ;; Do not prompt to resume an active clock
            ;org-clock-persist-query-resume nil
            ;; Resume clocking task on clock-in if the clock line is open
            org-clock-in-resume t
            org-clock-in-switch-to-state "STARTED"
            org-clock-out-remove-zero-time-clocks t
            org-clock-out-when-done t
            org-clock-idle-time 20
            ;; Include current clocking task in clock reports
            org-clock-report-include-clocking-task t)

      ;; Resume clocking tasks when emacs is restarted
      (org-clock-persistence-insinuate)))
#+END_SRC

** Agenda

*** Basic Configuration

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-agenda
    :commands (org-agenda org-agenda-list)
    :config
    (setq org-agenda-files `(,org-directory)
          org-agenda-skip-unavailable-files t
          org-agenda-skip-deadline-if-done nil
          org-agenda-skip-scheduled-if-done nil
          org-agenda-restore-windows-after-quit t
          org-agenda-window-setup 'current-window
          org-agenda-show-all-dates t
          org-agenda-show-log t
          org-agenda-diary-file (expand-file-name "diary.org" org-directory)
          org-agenda-include-diary t))
#+END_SRC

*** Holidays

Turn off holidays I don't need.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (setq holiday-bahai-holidays nil
        holiday-islamic-holidays nil
        holiday-oriental-holidays nil)
#+END_SRC

*** Custom Agenda Commands

Below are our custom agenda commands:

| Key | Description                                   |
|-----+-----------------------------------------------|
| =d=   | Timeline for today, including a clock summary |
| =w=   | Items with status WAITING                     |
| =f=   | Important tasks that I might tend to avoid    |
| =p=   | Items by priority                             |
| =l=   | Scheduled ledger transactions by date         |

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'org-agenda
    (setq org-agenda-custom-commands
          '(("A" "üìÜ Agenda"
             ((agenda "")
              (tags-todo "/!STARTED"
                         ((org-agenda-overriding-header "In Progress")
                          (org-tags-match-list-sublevels nil)
                          (org-agenda-sorting-strategy '(priority-down
                                                         category-keep
                                                         effort-up))))
              (tags "REFILE"
                    ((org-agenda-overriding-header "Entries to Refile")
                     (org-tags-match-list-sublevels nil)))
              (tags "-REFILE/"
                    ((org-agenda-overriding-header "Entries to Archive")
                     (org-agenda-skip-function 'my-skip-non-archivable-tasks)
                     (org-tags-match-list-sublevels nil)))))
            ("d" "üïë Timeline for today"
             agenda ""
             ((org-agenda-ndays 1)
              (org-agenda-show-log t)
              (org-agenda-log-mode-items '(clock closed))
              (org-agenda-clockreport-mode t)
              (org-agenda-entry-types '())))
            ("w" "‚úã Waiting for"
             todo "WAITING"
             ((org-agenda-sorting-strategy '(priority-down))))
            ("f" "üéØ Focused tasks"
             todo "FOCUS"
             ((org-agenda-sorting-strategy '(priority-down))))
            ("p" "‚ùó By priority"
             ((tags-todo "+PRIORITY=\"A\"")
              (tags-todo "+PRIORITY=\"B\"")
              (tags-todo "+PRIORITY=\"\"")
              (tags-todo "+PRIORITY=\"C\""))
             ((org-agenda-prefix-format "%-10c %-10T %e ")
              (org-agenda-sorting-strategy '(priority-down
                                             tag-up
                                             category-keep
                                             effort-down))))
            ("l" "üìí Scheduled transactions"
             agenda "transaction"
             ((org-agenda-time-grid nil)
              (org-agenda-ndays 90)
              (org-agenda-include-diary nil)
              (org-agenda-show-all-dates nil)
              (org-agenda-remove-tags t)
              (org-agenda-repeating-timestamp-show-all nil)
              (org-deadline-warning-days 365)
              (org-agenda-filter-preset '("+transaction"))
              (org-agenda-entry-types '(:deadline)))))))
#+END_SRC

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Thanks to http://doc.norang.ca/org-mode.html
  (defun my-skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))
#+END_SRC

** Appointments

Use the =appt= package for displaying appointment alerts. The
following was derived from [[http://lists.gnu.org/archive/html/emacs-orgmode/2013-02/msg00644.html][this message]] on the Org mode mailing
list.

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package appt
    :config
    (progn
      (run-at-time "24:01" 3600 'org-agenda-to-appt)           ; Update appt list hourly
      (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ; Update appt list on agenda view

      (setq appt-message-warning-time '60) ; Send first warning 30 minutes before appointment
      (setq appt-display-interval '30)     ; Warn every 15 minutes from appt-message-warning-time
      (appt-activate 1)))                  ; Activate appointment notification
#+END_SRC

** Mobile

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-mobile
    :disabled t
    :config
    (progn
      ;; Set to the name of the file where new notes will be stored
      (setq org-mobile-inbox-for-pull (expand-file-name "mobile-flagged.org" org-directory)
            org-mobile-directory "~/Dropbox/Apps/MobileOrg"
            org-mobile-agendas '("a")
            org-mobile-force-id-on-agenda-items nil
            ;; org-mobile-encryption-password is set in private.el
            org-mobile-use-encryption t)

      (defvar my-org-mobile-sync-timer nil)
      (defvar my-org-mobile-sync-secs (* 60 45))

      (defun my-org-mobile-sync-pull-and-push ()
        (org-mobile-pull)
        (org-mobile-push)
        (when (fboundp 'sauron-add-event)
          (sauron-add-event 'org-mobile 2 "Finished MobileOrg sync")))

      (defun my-org-mobile-sync-start ()
        "Start automated `org-mobile-push'"
        (interactive)
        (setq my-org-mobile-sync-timer
              (run-with-idle-timer my-org-mobile-sync-secs t
                                   'my-org-mobile-sync-pull-and-push)))

      (defun my-org-mobile-sync-stop ()
        "Stop automated `org-mobile-push'"
        (interactive)
        (cancel-timer my-org-mobile-sync-timer))

      (add-hook 'after-init-hook 'my-org-mobile-sync-start)
      (add-hook 'kill-emacs-hook 'org-mobile-push)))
#+END_SRC

** External Capture

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-org-capture-todo (note)
    (let* ((org-file org-default-notes-file)
           (type 'entry)
           (headline nil)
           (template (concat "** " note
                             "\n   SCHEDULED: %t\n")))
      (my-org-capture-entry org-file headline template)))

  (defun my-org-capture-note (note)
    (let* ((org-file org-default-notes-file)
           (type 'entry)
           (headline nil)
           (template (concat "** %U " note "\n")))
      (my-org-capture-entry org-file headline template)))

  (defun my-org-capture-entry (org-file headline template)
    (let* ((type 'entry)
           (org-capture-entry
            (if (headline)
                `(entry
                  (file+headline ,org-file ,headline)
                  ,template :clock-keep t :immediate-finish t)
                `(entry
                  (file ,org-file)
                  ,template :clock-keep t :immediate-finish t))))
      (require 'org-capture)
      (my-org-capture-noninteractively)))

  ;; See http://stackoverflow.com/questions/22411626/generate-org-mode-objects-programmatically
  (defun my-org-capture-noninteractively ()
    (let* ((orig-buf (current-buffer))
           (annotation (if (and (boundp 'org-capture-link-is-already-stored)
                                org-capture-link-is-already-stored)
                           (plist-get org-store-link-plist :annotation)
                         (ignore-errors (org-store-link nil))))
           (entry org-capture-entry)
           initial)
      (setq initial (or org-capture-initial
                        (and (org-region-active-p)
                             (buffer-substring (point) (mark)))))
      (when (stringp initial)
        (remove-text-properties 0 (length initial) '(read-only t) initial))
      (when (stringp annotation)
        (remove-text-properties 0 (length annotation)
                                '(read-only t) annotation))
      (setq org-capture-plist (copy-sequence (nthcdr 3 entry)))
      (org-capture-put :target (nth 1 entry))
      (let ((txt (nth 2 entry)) (type (or (nth 0 entry) 'entry)))
        (when (or (not txt) (and (stringp txt) (not (string-match "\\S-" txt))))
          (cond
           ((eq type 'item) (setq txt "- %?"))
           ((eq type 'checkitem) (setq txt "- [ ] %?"))
           ((eq type 'table-line) (setq txt "| %? |"))
           ((member type '(nil entry)) (setq txt "* %?\n  %a"))))
        (org-capture-put :template txt :type type))
      (org-capture-get-template)
      (org-capture-put :original-buffer orig-buf
                       :original-file (or (buffer-file-name orig-buf)
                                          (and (featurep 'dired)
                                               (car (rassq orig-buf
                                                           dired-buffers))))
                       :original-file-nondirectory
                       (and (buffer-file-name orig-buf)
                            (file-name-nondirectory
                             (buffer-file-name orig-buf)))
                       :annotation annotation
                       :initial initial
                       :return-to-wconf (current-window-configuration)
                       :default-time
                       (or org-overriding-default-time
                           (org-current-time)))
      (org-capture-set-target-location)
      (condition-case error
          (org-capture-put :template (org-capture-fill-template))
        ((error quit)
         (if (get-buffer "*Capture*") (kill-buffer "*Capture*"))
         (error "Capture abort: %s" error)))
      (setq org-capture-clock-keep (org-capture-get :clock-keep))
      (condition-case error
          (org-capture-place-template
           (equal (car (org-capture-get :target)) 'function))
        ((error quit)
         (if (and (buffer-base-buffer (current-buffer))
                  (string-match "\\`CAPTURE-" (buffer-name)))
             (kill-buffer (current-buffer)))
         (set-window-configuration (org-capture-get :return-to-wconf))
         (error "Error.")))
      (if (and (derived-mode-p 'org-mode)
               (org-capture-get :clock-in))
          (condition-case nil
              (progn
                (if (org-clock-is-active)
                    (org-capture-put :interrupted-clock
                                     (copy-marker org-clock-marker)))
                (org-clock-in)
                (org-set-local 'org-capture-clock-was-started t))
            (error
             "Could not start the clock in this capture buffer")))
      (if (org-capture-get :immediate-finish)
          (org-capture-finalize))))
#+END_SRC

** Calendar

The [[https://github.com/kiwanami/emacs-calfw][Calfw]] package provides a graphical calendar representation of the
Org agenda (as well as other calendar formats).

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package calfw-org
    :ensure calfw
    :config
    (setq cfw:fchar-junction ?‚ïã
          cfw:fchar-vertical-line ?‚îÉ
          cfw:fchar-horizontal-line ?‚îÅ
          cfw:fchar-left-junction ?‚î£
          cfw:fchar-right-junction ?‚î´
          cfw:fchar-top-junction ?‚î≥
          cfw:fchar-top-left-corner ?‚îè
          cfw:fchar-top-right-corner ?‚îì))

  (defun my-open-org-calendar ()
    "Open an org schedule calendar in a new buffer.

  This function is adapted from cfw:open-org-calendar."
    (interactive)
    (save-excursion
      (let* ((source1 (cfw:org-create-source "SkyBlue"))
             (cp (cfw:create-calendar-component-buffer
                  :view 'month
                  :contents-sources (list source1)
                  :custom-map cfw:org-schedule-map
                  :sorter 'cfw:org-schedule-sorter)))
        (switch-to-buffer (cfw:cp-get-buffer cp)))))
#+END_SRC

** Invoicing

#+NAME: org
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar invoice-dir "~/Documents/Invoices/")
  (defvar invoice-template-path (expand-file-name "_template.org" invoice-dir))

  (defun my-invoice-next-number ()
    "Get next sequential invoice number. Invoice numbers are in the format YYYYXXX,
  where YYYY is the current year and XXX is a zero-padded sequential counter
  modulo 1000. Ex.: 2016001."
    (concat (format-time-string "%Y" (current-time))
            (format "%03d" (% (1+ (string-to-number
                                (substring (car (last (directory-files
                                        invoice-dir
                                        nil
                                        "^[0-9]+\.org$"))) 4 7))) 1000))))

  (defun my-invoice-get-path (number)
    "Derive invoice file path from invoice NUMBER."
    (format "%s/%s.org" invoice-dir number))

  (defun my-invoice-create (scope-file)
    "Make a new invoice from given file and date range."
    (interactive "forg file: ")
    (let ((invoice-number (my-invoice-next-number))
          (invoice-date (format-time-string "%m/%d/%Y" (current-time)))
          (invoice-start (org-read-date nil t nil "Choose invoice start" nil "-2Mon"))
          (invoice-end (org-read-date nil nil nil "Choose invoice end" nil "-Sun")))
      (find-file (my-invoice-get-path invoice-number))
      (insert-file-contents invoice-template-path)
      (goto-char (point-min))
      (while (search-forward "@INVOICE_NUMBER@" nil t)
        (replace-match invoice-number))
      (goto-char (point-min))
      (while (search-forward "@SCOPE_FILE@" nil t)
        (replace-match scope-file))
      (org-update-all-dblocks)))

  (defun my-invoice-create-from-current-buffer-file ()
    "Make a new invoice from current buffer's file and given date range."
    (interactive)
    (my-invoice-create (buffer-file-name)))
#+END_SRC

* Communications

** Email

[[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] ("mu for Emacs") is an Elisp mail client and front end to [[http://www.djcbsoftware.nl/code/mu/][mu]],
a tool for indexing and searching e-mail messages stored in the
Maildir format. It's more minimalistic than the popular Gnus and has a
saner interface.

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package mu4e
    :load-path "~/src/mu/mu4e"
    :commands (mu4e mu4e~start)
    :init
    (progn
      (evil-leader/set-key "M" #'my-mu4e-view-today)

      (defun my-mu4e-view-today ()
        "Invoke mu4e and jump directly to the today bookmark."
        (interactive)
        (mu4e~start)
        (mu4e-headers-search-bookmark (mu4e-get-bookmark-query ?t))))
    :config
    (progn
      (setq mu4e-sent-folder "/Sent"
            mu4e-drafts-folder "/Drafts"
            mu4e-trash-folder "/Trash"
            mu4e-refile-folder "/Archive"
            mu4e-attachment-dir "~/Downloads"
            mu4e-maildir-shortcuts '(("/INBOX"    . ?i)
                                     ("/Drafts"   . ?D)
                                     ("/Domestic" . ?d)
                                     ("/GitHub"   . ?g)
                                     ("/Hello"    . ?h)
                                     ("/Domains"  . ?m)
                                     ("/Receipts" . ?r)
                                     ("/Sent"     . ?s)
                                     ("/Trash"    . ?T)
                                     ("/Big Tech/Logs"       . ?l)
                                     ("/Big Tech/TeamworkPM" . ?t))
            mu4e-update-interval 60 ; seconds
            mu4e-hide-index-messages t
            mu4e-use-fancy-chars t
            mu4e-headers-seen-mark      '("S" . "‚úî")
            mu4e-headers-unread-mark    '("u" . "‚óè")
            mu4e-headers-new-mark       '("N" . "‚óã")
            mu4e-headers-replied-mark   '("R" . "‚Üê")
            mu4e-headers-passed-mark    '("P" . "‚Üí")
            mu4e-headers-flagged-mark   '("F" . "‚öë")
            mu4e-headers-draft-mark     '("D" . "‚öí")
            mu4e-headers-encrypted-mark '("x" . "e")
            mu4e-headers-signed-mark    '("s" . "s")
            mu4e-headers-trashed-mark   '("T" . "√ó")
            mu4e-headers-attach-mark    '("a" . "‚öìÔ∏é")
            mu4e-headers-visible-flags  '(draft flagged passed replied unread)
            mu4e-headers-default-prefix     '("|" . "‚îÇ")
            mu4e-headers-has-child-prefix   '("+" . "‚îî")
            mu4e-headers-first-child-prefix '("\\" . "‚îî")
            mu4e-headers-include-related nil
            mu4e-headers-date-format    "%F %R"
            mu4e-headers-fields         '((:human-date .  16)
                                          (:flags      .   6)
                                          (:from       .  24)
                                          (:subject    . nil))
            mu4e-bookmarks '(("date:today..now" "Today's messages" ?t)
                             ("date:7d..now" "Last 7 days" ?w)
                             ("flag:unread AND NOT flag:trashed" "Unread messages" ?u)
                             ("flag:flagged" "Flagged messages" ?f)
                             ("to:*bigtech.com AND NOT flag:trashed" "Work-related messages" ?W))
            mu4e-compose-signature-auto-include nil
            mu4e-view-prefer-html t
            mu4e-html2text-command "elinks -dump"
            mu4e-alert-title "Mail"
            mail-user-agent 'mu4e-user-agent)

      (defun my-mu4e-action-view-in-browser (msg)
        "View the body of the message in a web browser."
        (interactive)
        (let ((html (mu4e-msg-field (mu4e-message-at-point t) :body-html))
              (tmpfile (format "%s/%d.html" temporary-file-directory (random))))
          (unless html (error "No html part for this message"))
          (with-temp-file tmpfile
            (insert html))
          (browse-url (concat "file://" tmpfile))))

      (add-to-list 'mu4e-view-actions
                   '("browser" . my-mu4e-action-view-in-browser) t)

      (add-hook 'mu4e-view-mode-hook 'epa-mail-mode)
      (add-hook 'mu4e-compose-mode-hook 'epa-mail-mode)

      (defun my-insert-contact (&optional start)
        (interactive)
        (let ((mail-abbrev-mode-regexp mu4e~compose-address-fields-regexp)
              (eoh ;; end-of-headers
               (save-excursion
                 (goto-char (point-min))
                 (search-forward-regexp mail-header-separator nil t))))
          (when (and eoh (> eoh (point)) (mail-abbrev-in-expansion-header-p))
            (let* ((end (point))
                   (start
                    (or start
                        (save-excursion
                          (re-search-backward "\\(\\`\\|[\n:,]\\)[ \t]*")
                          (goto-char (match-end 0))
                          (point))))
                   (contact
                    (ido-completing-read "Contact: "
                                         mu4e~contacts-for-completion
                                         nil
                                         nil
                                         (buffer-substring-no-properties start end))))
              (unless (equal contact "")
                (kill-region start end)
                (insert contact))))))

      (defun my-make-mu4e-mode-evil ()
        "Turn mu4e buffers evil."
        (evil-make-overriding-map mu4e-main-mode-map 'motion)
        (evil-define-key 'motion mu4e-main-mode-map "h" #'mu4e~headers-jump-to-maildir)    ; Was j

        (evil-make-overriding-map mu4e-headers-mode-map 'motion)
        (evil-define-key 'motion mu4e-headers-mode-map "h" #'mu4e~headers-jump-to-maildir) ; Was j
        (evil-define-key 'motion mu4e-headers-mode-map "j" #'mu4e-headers-next)

        (evil-make-overriding-map mu4e-view-mode-map 'motion)
        (evil-define-key 'motion mu4e-view-mode-map "h" #'mu4e~headers-jump-to-maildir)    ; Was j
        (evil-define-key 'motion mu4e-view-mode-map "j" #'mu4e-view-headers-next)
        (evil-define-key 'motion mu4e-view-mode-map "k" #'mu4e-view-headers-prev)

        (evil-define-key 'insert mu4e-compose-mode-map (kbd "C-l") #'my-insert-contact)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "m m" #'message-send-and-exit)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "k" #'message-kill-buffer)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "m e" #'mml-secure-message-sign-encrypt)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "m c" #'mml-secure-message-encrypt)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "m s" #'mml-secure-message-sign)
        (evil-leader/set-key-for-mode 'mu4e-compose-mode "m f" #'mml-attach-file)
        (evil-leader/set-key-for-mode 'epa-mail-mode "m d" #'epa-mail-decrypt)
        (evil-leader/set-key-for-mode 'epa-mail-mode "m v" #'epa-mail-verify))

      (my-make-mu4e-mode-evil)))
#+END_SRC

Start mu4e by issuing =M-x mu4e RET=. The interface is fairly self-explanatory.

The mu4e-alert package adds alerts and a mode-line indicator for new mail:

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package mu4e-alert
    :ensure t
    :init
    (progn
      (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
      (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)))
#+END_SRC

** RSS

[[https://github.com/skeeto/elfeed][Elfeed]] is an RSS/Atom reader. A list of feeds to fetch should be
listed in ~elfeed-feeds~. Unfortunately, it fails to retrieve or parse a
large proportion of feeds.

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'elfeed
    (evil-make-overriding-map elfeed-search-mode-map 'motion)
    (evil-make-overriding-map elfeed-show-mode-map 'motion))
#+END_SRC

Open the Elfeed buffer by issuing =M-x elfeed RET=.

** Terminal Notifier

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar my-notifier-program-name
    "terminal-notifier")

  (defun my-send-notification (title msg &optional group)
    (let ((group (if group (format " -group %s" group)))
          (msg (format " -message %s" (shell-quote-argument msg)))
          (title (format " -title %s" (shell-quote-argument title)))
          (sender " -sender org.gnu.Emacs"))
      (shell-command (concat my-notifier-program-name
                             msg
                             title
                             sender
                             group))))
#+END_SRC

** Alert

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package alert
    :ensure t
    :config
    (progn
      (setq alert-default-style 'terminal-notifier)

      (alert-define-style 'terminal-notifier
                          :title "Terminal Notifier"
                          :notifier
                          (lambda (info)
                            (my-send-notification
                             (plist-get info :title)
                             (plist-get info :message)
                             (plist-get info :category))))))
#+END_SRC

** Sauron

[[https://github.com/djcb/sauron][Sauron]] provides an event log that integrates with =alert.el= and ERC.

#+NAME: communications
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package sauron
    :ensure t
    :config
    (progn
      ;; Pass notifications through to alert.el
      (add-hook 'sauron-event-added-functions 'sauron-alert-el-adapter)

      (setq sauron-hide-mode-line t
            sauron-modules '(sauron-org
                             sauron-notifications))

      (evil-leader/set-key "s" 'sauron-toggle-hide-show)

      (sauron-start-hidden)))
#+END_SRC

* Configuration Layout

Here we define the =emacs.el= file that gets generated by the source
blocks in our Org document. This is the file that actually gets
loaded on startup. The placeholders in angled brackets correspond to
the ~NAME~ directives above the ~SRC~ blocks throughout this document.

#+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
;;; emacs.el --- Emacs configuration generated via Org Babel

;;; Commentary:

;; Do not modify this file by hand.  It was automatically generated
;; from `emacs.org` in the same directory.  See that file for more
;; information.

;;; Code:

;; Configuration group: init-before
<<init-before>>

;; Configuration group: appearance
<<appearance>>

;; Configuration group: evil
<<evil>>

;; Configuration group: editing
<<editing>>

;; Configuration group: navigation-completion
<<navigation-completion>>

;; Configuration group: org
<<org>>

;; Configuration group: communications
<<communications>>

;; Configuration group: init-after
<<init-after>>

;; emacs.el ends here
#+END_SRC

* Wish List

Functionality I want or things that need to be fixed:

- Use Emacs for email. My last attempt with mu4e was unsuccessful because:
  - Managing windows in a frame shared with other text editing
    activities was awkward.
  - It didn't automatically decrypt mail when viewing (and I can't get
    gpgagent to work).
  - It failed to decrypt email sent to myself if it included an
    attachment.
  - New-mail notifications had to be hacked together, and ultimately
    they were unreliable.
  - Having to first mark messages and then act on them was an annoying
    paradigm. Can be solved with custom key bindings.
  - I receive too much HTML email and don't have a suitable way to
    display it. Various HTML-to-text solutions were insufficient and
    viewing the message in the browser allows for nefarious tracking
    to take place. Look into mu4e's [[https://github.com/djcb/mu/blob/master/mu4e/mu4e-contrib.el][contrib file]], which includes a
    potential solution.
  - Once offlineimap stopped fetching mail, and I didn't realize it
    for a whole day.
- Sleuth.vim ported to Emacs.
- Paredit for Evil mode.
- Ex commands for specific modes (e.g., org-capture-mode):
  https://bitbucket.org/lyro/evil/issue/399/issues-with-org-src-mode
